%!
(dmmlib/base.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run

/atranslate { aload pop translate } def

/drawmaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position 0 2 getinterval { 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        /walls_i 0 def
        4 {
            0.5 inset sub dup neg goto
            walls walls_i get not {
                0.5 dup inset sub neg goto
                0.5 dup inset sub goto
            } if
            /walls_i walls_i 1 add def
        } circrepeat
        closepath
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 3 { /i arg
            gsave
                i 0 sub 90 mul rotate
                walls i get {
                    % don't draw walls for link cells
                    position length 3 ne {
                        0.5 inset sub dup neg goto
                        0.5 inset sub dup goto
                        stroke
                    } if
                } {
                    0.5 inset sub dup neg goto
                    0.5 dup inset sub neg goto
                    stroke
                    0.5 inset sub dup goto
                    0.5 dup inset sub goto
                    stroke
                } ifelse
            grestore
        } for
    } def

    mazeengine

} def

/drawupsilonmaze { /grid arg
    /octagon_offset 0.5 22.5 tan mul def
    /diamond_offset 0.5 octagon_offset sub def
    /getcenter { /position arg
        [ position 0 2 getinterval { 2 div 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            4 {
                0.5 octagon_offset neg goto
                0.5 octagon_offset goto
            } circrepeat closepath
        } {
            4 {
                diamond_offset 0 goto
            } circrepeat closepath
        } ifelse
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            0 1 7 { /i arg
                walls i get {
                    gsave
                        i 45 mul rotate
                        0.5 octagon_offset neg goto
                        0.5 octagon_offset goto
                        stroke
                    grestore
                } if
            } for
        } {
            0 1 3 { /i arg
                walls i get {
                    gsave
                        i 90 mul rotate
                        diamond_offset 0 goto
                        0 diamond_offset goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/drawzetamaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position 0 2 getinterval { 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        -0.5 -0.5 0.5 0.5 box
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 2 6 { /i arg
            walls i get {
                gsave
                    i 0 sub 45 mul rotate
                    0.5 -0.5 goto
                    0.5 0.5 goto
                    stroke
                grestore
            } if
        } for
        % zeta paths
        1 2 7 { /i arg
            walls i get not {
                gsave
                    i 45 mul rotate
                    0.5 thicken
                    0.5 0 dot
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawcirclemaze { /grid arg
    % grid fields:
    % widths: array of ints, counting cells in each ring (from the middle out)
    % cells: list of lists containing coord (ring, cell) then list of boolean walls for ccw, in, cw, outs

    /widths grid /widths get def
    /radius widths length def

    (L) set_polar_corner_mode

    /getcenter {
        2 dict begin
            /coord arg
            % given a (ring, cell) coordinate, return (r, theta) of center
            coord 0 2 getinterval aload pop /cell arg /ring arg
            /r ring def
            /theta ring 0 eq { 0 } {
                widths ring get 360 exch div cell 0.5 add mul
            } ifelse def
            [ r theta polar]
        end
    } def

    /getbox {
        % given a ring/cell coordinate, return ccw, in, cw, out dimensions
        % of the entire box, not including insets
        % not valid for ring 0
        2 dict begin
            0 2 getinterval /coord arg
            coord aload pop /cell arg /ring arg
            /in ring 0.5 sub def
            /out ring 0.5 add def
            /turn widths ring get 360 exch div def
            /ccw cell turn mul def
            /cw cell 1 add turn mul def
            [ccw in cw out]
        end
    } def
    /ao 10 dict def
    /get_ao { /query_rad arg
        ao query_rad known not {
            ao query_rad
                inset query_rad div asin 
            put
        } if
        ao query_rad get
    } def
    /ao_point { /direction arg /angle arg /rad arg
        rad angle rad get_ao direction mul add
    } def
    /getcellpath { /walls arg /position arg
        inset 0 eq {
            position 0 get 0 ne {
                /cbox position getbox def
                cbox 1 get cbox 0 get pgoto
                cbox 3 get cbox 0 get pgoto
                cbox 3 get cbox 2 get pgoto
                cbox 1 get cbox 2 get pgoto
                cbox 1 get cbox 0 get pgoto
                closepath
            } {
                0 0 0.5 circle closepath
            } ifelse
        } {
            % deal with insets
            /outstart position 0 get 0 eq { 0 } { 3 } ifelse def
            % figure out angle offsets as we go
            outstart 0 ne {
                position getbox aload pop /out arg /cw arg /in arg /ccw arg
                /nin in inset add def
            } {
                /ccw 0 def
                /cw 360 def
                /out 0.5 def
            } ifelse
            /nout out inset sub def
            outstart 0 ne {
                % side walls
                nout cw -1 ao_point pgoto
                walls 0 get {
                    nin cw -1 ao_point polar goto
                } {
                    nout cw pgoto
                    nin cw polar goto
                    nin cw -1 ao_point pgoto
                } ifelse
                walls 1 get {
                    nin ccw 1 ao_point pgoto
                } {
                    in cw -1 ao_point polar goto
                    in ccw 1 ao_point pgoto
                    nin ccw 1 ao_point polar goto
                } ifelse
                walls 2 get {
                    nout ccw 1 ao_point polar goto
                } {
                    nin ccw pgoto
                    nout ccw polar goto
                    nout ccw 1 ao_point pgoto
                 } ifelse
            } if
            /outwall_n walls length outstart sub def
            outwall_n 0 eq {
                nout ccw 1 ao_point pgoto
            } {
                /outwall_len cw ccw sub outwall_n div def
                0 1 outwall_n 1 sub { /i arg
                    /door_ccw i       outwall_len mul ccw add def
                    /door_cw  i 1 add outwall_len mul ccw add def
                    nout door_ccw 1 ao_point pgoto
                    walls outstart i add get {
                        nout door_cw -1 ao_point pgoto
                    } {
                        out door_ccw 1 ao_point polar goto
                        out door_cw -1 ao_point pgoto
                        nout door_cw -1 ao_point polar goto
                    } ifelse
                } for
            } ifelse
        } ifelse
    } def

    /mgoto { ralop pgoto } def

    /drawwalls { /walls arg /position arg
        /all_walls position length 2 eq def
        /outstart position 0 get 0 eq { 0 } { 3 } ifelse def
        outstart 0 ne {
            position getbox aload pop /out arg /cw arg /in arg /ccw arg
            /nin in inset add def
        } {
            /ccw 0 def
            /cw 360 def
            /out 0.5 def
        } ifelse
        /nout out inset sub def
        outstart 0 ne {
            % side walls
            walls 0 get {
                all_walls {
                    nout cw -1 ao_point pgoto
                    nin cw -1 ao_point polar goto
                    stroke
                } if
            } {
                nout cw pgoto
                stroke
                nin cw polar goto
                nin cw -1 ao_point pgoto
                stroke
            } ifelse
            walls 1 get {
                all_walls {
                    nin cw -1 ao_point pgoto
                    nin ccw 1 ao_point pgoto
                    stroke
                } if
            } {
                nin cw -1 ao_point pgoto
                in cw -1 ao_point polar goto
                stroke
                in ccw 1 ao_point pgoto
                nin ccw 1 ao_point polar goto
                stroke
            } ifelse
            walls 2 get {
                all_walls {
                    nin ccw 1 ao_point polar goto
                    nout ccw 1 ao_point polar goto
                    stroke
                } if
            } {
                nin ccw 1 ao_point polar goto
                nin ccw pgoto
                stroke
                nout ccw polar goto
                nout ccw 1 ao_point pgoto
                stroke
             } ifelse
        } if
        /outwall_n walls length outstart sub def
        outwall_n 0 eq {
            nout ccw 1 ao_point pgoto
        } {
            /outwall_len cw ccw sub outwall_n div def
            0 1 outwall_n 1 sub { /i arg
                /door_ccw i       outwall_len mul ccw add def
                /door_cw  i 1 add outwall_len mul ccw add def
                walls outstart i add get {
                    all_walls {
                        i 0 ne {
                            nout door_ccw -1 ao_point pgoto
                        } if
                        nout door_ccw 1 ao_point pgoto
                        nout door_cw -1 ao_point pgoto
                        stroke
                    } if
                } {
                    i 0 ne {
                        nout door_ccw -1 ao_point pgoto
                    } if
                    nout door_ccw 1 ao_point pgoto
                    out door_ccw 1 ao_point polar goto
                    stroke
                    out door_cw -1 ao_point pgoto
                    nout door_cw -1 ao_point polar goto
                    stroke
                } ifelse
            } for
        } ifelse
        stroke
    } def

    mazeengine

} def

/s3h 3 sqrt 2 div def

/h2c { /hexcoord arg
    % convert hex coordinate to x,y
    hexcoord aload pop /n arg /ese arg
    [
        ese s3h mul
        ese neg half n add
    ]
} def


/drawhexmaze { /grid arg
    % grid fields:
    % radius: count of cells in a radius, not including center
        % full distance across is 2 * radius + 1
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, n, wnw, wsw, s, ese
    % field: as before
    % path: as before

    /radius grid /radius get def

    /getcenter { h2c } def

    /getcellpath { /walls arg /position arg
        % one cell, centered on position
        position getcenter atranslate
        6 {
            3 sqrt recip 0 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 5 { /i arg
            walls i get {
                gsave
                    i 0.5 add 60 mul rotate
                    0.5 3 sqrt 2 mul recip neg goto
                    0.5 3 sqrt 2 mul recip goto
                    stroke
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawtrimaze { /grid arg
    % grid fields:
    % width: count of cells across one side
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, wnw, s
        % for n, wsw, ese
    % field: as before
    % path: as before

    /width grid /width get def

    /getcenter { /hexcoord arg
        % convert hex coordinate to x,y
        hexcoord aload pop /n arg /ese arg
        [
            ese s3h mul
            ese neg half n add
        ]
    } def

    /getcellpath { /walls arg /tripos arg
        % one cell, centered on tripos, oriented appropriately
        tripos getcenter atranslate
        tripos aload pop add 3 mod 2 eq {
            180 rotate
        } if
        3 {
            0 1 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position 0 2 getinterval aload pop add 3 mymod cvi /tritype arg
        tritype 1 eq {
            0 setsinebowcolor doot
        } {
            tritype 0 eq { 30 rotate } { 90 rotate } ifelse
            0 1 2 { /i arg
                walls i get {
                    gsave
                        i 120 mul rotate
                        0.5 s3h neg goto
                        0.5 s3h goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/mazeengine {
    gsave
        0.1 setlinewidth 1 setlinecap 1 setlinejoin

        grid /weave known {
            0.1
        } {
            0
        } ifelse /inset arg
        grid /field known {
            /fieldstep grid /field get length 1 sub recip def
        } if

        grid /cells get {
            gsave
                /cell arg
                cell 0 get /position arg
                cell 1 get /walls arg
                cell 2 get /field arg
                grid /field known {
                    gsave
                        field fieldstep mul 360 mul setsinebowcolor
                        position walls getcellpath fill
                    grestore
                } if
                position walls drawwalls
            grestore
        } forall

        grid /path known {
            grid /path get {
                getcenter aload pop mgoto
            } forall
            grid /field known {
                1 setgray
            } {
                1 0 0 setrgbcolor
            } ifelse
            stroke
            grid /path get 0 get getcenter aload pop dot
            grid /path get dup length 1 sub get getcenter aload pop dot
        } if
    grestore
} def

%%EndProlog
