%!
(dmmlib/base.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run

/atranslate { aload pop translate } def

/drawrectmaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position 0 2 getinterval { 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        /walls_i 0 def
        4 {
            0.5 inset sub dup neg goto
            walls walls_i get not {
                0.5 dup inset sub neg goto
                0.5 dup inset sub goto
            } if
            /walls_i walls_i 1 add def
        } circrepeat
        closepath
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 3 { /i arg
            gsave
                i 0 sub 90 mul rotate
                walls i get {
                    % don't draw walls for link cells
                    position length 3 ne {
                        0.5 inset sub dup neg goto
                        0.5 inset sub dup goto
                        stroke
                    } if
                } {
                    0.5 inset sub dup neg goto
                    0.5 dup inset sub neg goto
                    stroke
                    0.5 inset sub dup goto
                    0.5 dup inset sub goto
                    stroke
                } ifelse
            grestore
        } for
    } def

    mazeengine

} def

/drawupsilonmaze { /grid arg
    /octagon_offset 0.5 22.5 tan mul def
    /diamond_offset 0.5 octagon_offset sub def
    /getcenter { /position arg
        [ position 0 2 getinterval { 2 div 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            4 {
                0.5 octagon_offset neg goto
                0.5 octagon_offset goto
            } circrepeat closepath
        } {
            4 {
                diamond_offset 0 goto
            } circrepeat closepath
        } ifelse
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            0 1 7 { /i arg
                walls i get {
                    gsave
                        i 45 mul rotate
                        0.5 octagon_offset neg goto
                        0.5 octagon_offset goto
                        stroke
                    grestore
                } if
            } for
        } {
            0 1 3 { /i arg
                walls i get {
                    gsave
                        i 90 mul rotate
                        diamond_offset 0 goto
                        0 diamond_offset goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/drawzetamaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position 0 2 getinterval { 0.5 add } forall ]
    } def
    /getcellpath { /walls arg /position arg
        position getcenter atranslate
        -0.5 -0.5 0.5 0.5 box
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 2 6 { /i arg
            walls i get {
                gsave
                    i 0 sub 45 mul rotate
                    0.5 -0.5 goto
                    0.5 0.5 goto
                    stroke
                grestore
            } if
        } for
        % zeta paths
        1 2 7 { /i arg
            walls i get not {
                gsave
                    i 45 mul rotate
                    0.5 thicken
                    0.5 0 dot
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawcirclemaze { /grid arg
    % grid fields:
    % widths: array of ints, counting cells in each ring (from the middle out)
    % centercell: true if 0,0 is a single circle in the middle
    % cells: list of lists containing coord (ring, cell) then list of boolean walls for ccw, in, cw, outs

    /widths grid /widths get def
    /radius widths length def
    /center_cell grid /center_cell get def

    (L) set_polar_corner_mode

    /getcenter {
        2 dict begin
            /coord arg
            % given a (ring, cell) coordinate, return (r, theta) of center
            coord 0 2 getinterval aload pop /cell arg /ring arg
            /r ring center_cell not { 0.5 add } if def
            /theta center_cell ring 0 eq and { 0 } {
                widths ring get 360 exch div cell 0.5 add mul
            } ifelse def
            [ r theta polar]
        end
    } def

    /getbox {
        % given a ring/cell coordinate, return ccw, in, cw, out dimensions
        % of the entire box, not including insets
        % not valid for center cell
        2 dict begin
            0 2 getinterval /coord arg
            coord aload pop /cell arg /ring arg
            /out ring center_cell {0.5 add} {1 add} ifelse def
            /in out 1 sub def
            /turn widths ring get 360 exch div def
            /ccw cell turn mul def
            /cw cell 1 add turn mul def
            [ccw in cw out]
        end
    } def
    /ao 10 dict def
    % special handling for 0
    ao 0 0 put
    /get_ao { /query_rad arg
        ao query_rad known not {
            ao query_rad
                inset query_rad div asin
            put
        } if
        ao query_rad get
    } def
    /ao_point { /direction arg /angle arg /rad arg
        rad angle rad get_ao direction mul add
    } def

    /getcellpath { /walls arg /position arg
        % sometimes we need a special lowest point
        center_cell not inset 0 ne and {
            /innerangle where {
                pop
            } {
                /innerangle 360 widths 0 get div half def
                /innerpoint inset innerangle sin div def
            } ifelse
        } if

        inset 0 eq {
            center_cell not position 0 get 0 ne or {
                /cbox position getbox def
                cbox 1 get cbox 0 get pgoto
                cbox 3 get cbox 0 get pgoto
                cbox 3 get cbox 2 get pgoto
                cbox 1 get cbox 2 get pgoto
                cbox 1 get cbox 0 get pgoto
                closepath
            } {
                0 0 0.5 circle closepath
            } ifelse
        } {
            % deal with insets
            /outstart position 0 get 0 eq {
                center_cell { 0 } { 2 } ifelse
            } { 3 } ifelse def
            % flag for innerpoint handling
            /inner_flag position 0 get 0 eq center_cell not and def

            % figure out angle offsets as we go
            outstart 0 ne {
                position getbox aload pop /out arg /cw arg /in arg /ccw arg
                /nin in inset add def
            } {
                /ccw 0 def
                /cw 360 def
                /out 0.5 def
            } ifelse
            /nout out inset sub def
            outstart 0 ne {
                % side wall
                nout cw -1 ao_point pgoto
                walls 0 get {
                    inner_flag not {
                        nin cw -1 ao_point polar goto
                    } if
                } {
                    nout cw pgoto
                    inner_flag {
                        innerpoint cw polar goto
                        innerpoint ccw innerangle add pgoto
                    } {
                        nin cw polar goto
                        nin cw -1 ao_point pgoto
                    } ifelse
                } ifelse
                % lower wall if appropriate
                position 0 get 0 ne {
                    walls 1 get {
                        nin ccw 1 ao_point pgoto
                    } {
                        in cw -1 ao_point polar goto
                        in ccw 1 ao_point pgoto
                        nin ccw 1 ao_point polar goto
                    } ifelse
                } {
                    innerpoint ccw innerangle add polar goto
                } ifelse
                % other side
                walls outstart 1 sub get {
                    nout ccw 1 ao_point polar goto
                } {
                    inner_flag {
                        innerpoint ccw pgoto
                    } {
                        nin ccw pgoto
                    } ifelse
                    nout ccw polar goto
                    nout ccw 1 ao_point pgoto
                 } ifelse
            } if
            /outwall_n walls length outstart sub def
            outwall_n 0 eq {
                nout ccw 1 ao_point pgoto
            } {
                /outwall_len cw ccw sub outwall_n div def
                0 1 outwall_n 1 sub { /i arg
                    /door_ccw i       outwall_len mul ccw add def
                    /door_cw  i 1 add outwall_len mul ccw add def
                    nout door_ccw 1 ao_point pgoto
                    walls outstart i add get {
                        nout door_cw -1 ao_point pgoto
                    } {
                        out door_ccw 1 ao_point polar goto
                        out door_cw -1 ao_point pgoto
                        nout door_cw -1 ao_point polar goto
                    } ifelse
                } for
            } ifelse
        } ifelse
    } def

    /mgoto { ralop pgoto } def

    /drawwalls { /walls arg /position arg
        /all_walls position length 2 eq def
        /outstart position 0 get 0 eq {
            center_cell { 0 } { 2 } ifelse
        } { 3 } ifelse def
        /inner_flag position 0 get 0 eq center_cell not and def
        outstart 0 ne {
            position getbox aload pop /out arg /cw arg /in arg /ccw arg
            /nin in inset add def
        } {
            /ccw 0 def
            /cw 360 def
            /out 0.5 def
        } ifelse
        /nout out inset sub def
        outstart 0 ne {
            % side walls
            walls 0 get {
                all_walls {
                    nout cw -1 ao_point pgoto
                    nout cw -1 ao_point pgoto
                    inner_flag {
                        innerpoint ccw innerangle add polar goto
                    } {
                        nin cw -1 ao_point polar goto
                    } ifelse
                    stroke
                } if
            } {
                nout cw -1 ao_point pgoto
                nout cw pgoto
                stroke
                inner_flag {
                    innerpoint cw polar goto
                    innerpoint ccw innerangle add pgoto
                } {
                    nin cw polar goto
                    nin cw -1 ao_point pgoto
                } ifelse
                stroke
            } ifelse
            position 0 get 0 ne {
                walls 1 get {
                    all_walls {
                        nin cw -1 ao_point pgoto
                        nin ccw 1 ao_point pgoto
                        stroke
                    } if
                } {
                    nin cw -1 ao_point pgoto
                    in cw -1 ao_point polar goto
                    stroke
                    in ccw 1 ao_point pgoto
                    nin ccw 1 ao_point polar goto
                    stroke
                } ifelse
            } if
            walls outstart 1 sub get {
                all_walls {
                    inner_flag {
                        innerpoint ccw innerangle add pgoto
                    } {
                        nin ccw 1 ao_point polar goto
                    } ifelse
                    nout ccw 1 ao_point polar goto
                    stroke
                } if
            } {
                inner_flag {
                    innerpoint ccw innerangle add pgoto
                    innerpoint ccw pgoto
                } {
                    nin ccw 1 ao_point polar goto
                    nin ccw pgoto
                } ifelse
                stroke
                nout ccw polar goto
                nout ccw 1 ao_point pgoto
                stroke
             } ifelse
        } if
        /outwall_n walls length outstart sub def
        outwall_n 0 eq {
            nout ccw 1 ao_point pgoto
        } {
            /full_circle position 0 get 0 eq center_cell and def
            /outwall_len cw ccw sub outwall_n div def
            0 1 outwall_n 1 sub { /door_i arg
                /door_ccw door_i       outwall_len mul ccw add def
                /door_cw  door_i 1 add outwall_len mul ccw add def
                walls outstart door_i add get {
                    all_walls {
                        door_i 0 ne full_circle or { nout door_ccw pgoto } if
                        nout door_ccw 1 ao_point pgoto
                        nout door_cw -1 ao_point pgoto
                        door_i outwall_n 1 sub ne full_circle or {
                            nout door_cw pgoto
                        } if
                        stroke
                    } if
                } {
                    door_i 0 ne full_circle or { nout door_ccw pgoto } if
                    nout door_ccw 1 ao_point pgoto
                    out door_ccw 1 ao_point polar goto
                    stroke
                    out door_cw -1 ao_point pgoto
                    nout door_cw -1 ao_point polar goto
                    door_i outwall_n 1 sub ne full_circle or { nout door_cw pgoto } if
                    stroke
                } ifelse
            } for
        } ifelse
        stroke
    } def

    grid /bg known {
        0 0 radius 2 mul circle fill
    } if
    mazeengine

} def

/drawpolygonmaze { /grid arg
    % grid fields:
    % widths: array of ints, counting cells in each ring (from the middle out)
    % sides: number of sides of the polygon, must divide into widths
    % centercell: true if 0,0 is a single shape in the middle
    % cells: list of lists containing coord (ring, cell) then list of boolean walls for ccw, in, cw, outs

    /widths grid /widths get def
    /radius widths length def
    /center_cell grid /center_cell get def
    /sides grid /sides get def
    sides set_polypolar_sides
    (L) set_polar_corner_mode

    /getcenter {
        2 dict begin
            /coord arg
            % given a (ring, cell) coordinate, return (r, theta) of center
            coord 0 2 getinterval aload pop /cell arg /ring arg
            /r ring center_cell not { 0.5 add } if def
            /theta center_cell ring 0 eq and { 0 } {
                widths ring get 360 exch div cell 0.5 add mul
            } ifelse def
            [ r theta polypolar ]
        end
    } def

    /getbox {
        % given a ring/cell coordinate, return ccw, in, cw, out dimensions
        % of the entire box, not including insets
        % not valid for center cell
        2 dict begin
            0 2 getinterval /coord arg
            coord aload pop /cell arg /ring arg
            /out ring center_cell {0.5 add} {1 add} ifelse def
            /in out 1 sub def
            /turn widths ring get 360 exch div def
            /ccw cell turn mul def
            /cw cell 1 add turn mul def
            [ccw in cw out]
        end
    } def
    /ao 10 dict def
    % special handling for 0
    ao 0 0 put
    /get_ao { /query_rad arg
        ao query_rad known not {
            ao query_rad
                inset query_rad div asin
            put
        } if
        ao query_rad get
    } def
    /ao_point { /direction arg /angle arg /rad arg
        rad angle rad get_ao direction mul add
    } def

    /getcellpath { /walls arg /position arg
        % sometimes we need a special lowest point
        center_cell not inset 0 ne and {
            /innerangle where {
                pop
            } {
                /innerangle 360 widths 0 get div half def
                /innerpoint inset innerangle sin div def
            } ifelse
        } if

        inset 0 eq {
            center_cell not position 0 get 0 ne or {
                /cbox position getbox def
                cbox 1 get cbox 0 get ppgoto
                cbox 3 get cbox 0 get ppgoto
                cbox 3 get cbox 2 get ppgoto
                cbox 1 get cbox 2 get ppgoto
                cbox 1 get cbox 0 get ppgoto
                closepath
            } {
                sides {
                    0.5 0 goto
                } circrepeat closepath
            } ifelse
        } {
            % deal with insets
            /outstart position 0 get 0 eq {
                center_cell { 0 } { 2 } ifelse
            } { 3 } ifelse def
            % flag for innerpoint handling
            /inner_flag position 0 get 0 eq center_cell not and def

            % figure out angle offsets as we go
            outstart 0 ne {
                position getbox aload pop /out arg /cw arg /in arg /ccw arg
                /nin in inset add def
            } {
                /ccw 0 def
                /cw 360 def
                /out 0.5 def
            } ifelse
            /nout out inset sub def
            outstart 0 ne {
                % side wall
                nout cw -1 ao_point ppgoto
                walls 0 get {
                    inner_flag not {
                        nin cw -1 ao_point polypolar goto
                    } if
                } {
                    nout cw ppgoto
                    inner_flag {
                        innerpoint cw polypolar goto
                        innerpoint ccw innerangle add ppgoto
                    } {
                        nin cw polypolar goto
                        nin cw -1 ao_point ppgoto
                    } ifelse
                } ifelse
                % lower wall if appropriate
                position 0 get 0 ne {
                    walls 1 get {
                        nin ccw 1 ao_point ppgoto
                    } {
                        in cw -1 ao_point polypolar goto
                        in ccw 1 ao_point ppgoto
                        nin ccw 1 ao_point polypolar goto
                    } ifelse
                } {
                    innerpoint ccw innerangle add polypolar goto
                } ifelse
                % other side
                walls outstart 1 sub get {
                    nout ccw 1 ao_point polypolar goto
                } {
                    inner_flag {
                        innerpoint ccw ppgoto
                    } {
                        nin ccw ppgoto
                    } ifelse
                    nout ccw polypolar goto
                    nout ccw 1 ao_point ppgoto
                 } ifelse
            } if
            /outwall_n walls length outstart sub def
            outwall_n 0 eq {
                nout ccw 1 ao_point ppgoto
            } {
                /outwall_len cw ccw sub outwall_n div def
                0 1 outwall_n 1 sub { /i arg
                    /door_ccw i       outwall_len mul ccw add def
                    /door_cw  i 1 add outwall_len mul ccw add def
                    nout door_ccw 1 ao_point ppgoto
                    walls outstart i add get {
                        nout door_cw -1 ao_point ppgoto
                    } {
                        out door_ccw 1 ao_point polypolar goto
                        out door_cw -1 ao_point ppgoto
                        nout door_cw -1 ao_point polypolar goto
                    } ifelse
                } for
            } ifelse
        } ifelse
    } def

    /mgoto { polyralop ppgoto } def

    /drawwalls { /walls arg /position arg
        /all_walls position length 2 eq def
        /outstart position 0 get 0 eq {
            center_cell { 0 } { 2 } ifelse
        } { 3 } ifelse def
        /inner_flag position 0 get 0 eq center_cell not and def
        outstart 0 ne {
            position getbox aload pop /out arg /cw arg /in arg /ccw arg
            /nin in inset add def
        } {
            /ccw 0 def
            /cw 360 def
            /out 0.5 def
        } ifelse
        /nout out inset sub def
        outstart 0 ne {
            % side walls
            walls 0 get {
                all_walls {
                    nout cw -1 ao_point ppgoto
                    nout cw -1 ao_point ppgoto
                    inner_flag {
                        innerpoint ccw innerangle add polypolar goto
                    } {
                        nin cw -1 ao_point polypolar goto
                    } ifelse
                    stroke
                } if
            } {
                nout cw -1 ao_point ppgoto
                nout cw ppgoto
                stroke
                inner_flag {
                    innerpoint cw polypolar goto
                    innerpoint ccw innerangle add ppgoto
                } {
                    nin cw polypolar goto
                    nin cw -1 ao_point ppgoto
                } ifelse
                stroke
            } ifelse
            position 0 get 0 ne {
                walls 1 get {
                    all_walls {
                        nin cw -1 ao_point ppgoto
                        nin ccw 1 ao_point ppgoto
                        stroke
                    } if
                } {
                    nin cw -1 ao_point ppgoto
                    in cw -1 ao_point polypolar goto
                    stroke
                    in ccw 1 ao_point ppgoto
                    nin ccw 1 ao_point polypolar goto
                    stroke
                } ifelse
            } if
            walls outstart 1 sub get {
                all_walls {
                    inner_flag {
                        innerpoint ccw innerangle add ppgoto
                    } {
                        nin ccw 1 ao_point polypolar goto
                    } ifelse
                    nout ccw 1 ao_point polypolar goto
                    stroke
                } if
            } {
                inner_flag {
                    innerpoint ccw innerangle add ppgoto
                    innerpoint ccw ppgoto
                } {
                    nin ccw 1 ao_point polypolar goto
                    nin ccw ppgoto
                } ifelse
                stroke
                nout ccw polypolar goto
                nout ccw 1 ao_point ppgoto
                stroke
             } ifelse
        } if
        /outwall_n walls length outstart sub def
        outwall_n 0 eq {
            nout ccw 1 ao_point ppgoto
        } {
            /full_circle position 0 get 0 eq center_cell and def
            /outwall_len cw ccw sub outwall_n div def
            0 1 outwall_n 1 sub { /door_i arg
                /door_ccw door_i       outwall_len mul ccw add def
                /door_cw  door_i 1 add outwall_len mul ccw add def
                walls outstart door_i add get {
                    all_walls {
                        door_i 0 ne full_circle or { nout door_ccw ppgoto } if
                        nout door_ccw 1 ao_point ppgoto
                        nout door_cw -1 ao_point ppgoto
                        door_i outwall_n 1 sub ne full_circle or {
                            nout door_cw ppgoto
                        } if
                        stroke
                    } if
                } {
                    door_i 0 ne full_circle or { nout door_ccw ppgoto } if
                    nout door_ccw 1 ao_point ppgoto
                    out door_ccw 1 ao_point polypolar goto
                    stroke
                    out door_cw -1 ao_point ppgoto
                    nout door_cw -1 ao_point polypolar goto
                    door_i outwall_n 1 sub ne full_circle or { nout door_cw ppgoto } if
                    stroke
                } ifelse
            } for
        } ifelse
        stroke
    } def

    grid /bg known {
        0 0 radius 2 mul circle fill
    } if
    mazeengine

} def

/s3h 3 sqrt 2 div def

/h2c { /hexcoord arg
    % convert hex coordinate to x,y
    hexcoord aload pop /n arg /ese arg
    [
        ese s3h mul
        ese neg half n add
    ]
} def


/drawhexmaze { /grid arg
    % grid fields:
    % radius: count of cells in a radius, not including center
        % full distance across is 2 * radius + 1
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, n, wnw, wsw, s, ese
    % field: as before
    % path: as before

    /radius grid /radius get def

    /getcenter { h2c } def

    /getcellpath { /walls arg /position arg
        % one cell, centered on position
        position getcenter atranslate
        6 {
            3 sqrt recip 0 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 5 { /i arg
            walls i get {
                gsave
                    i 0.5 add 60 mul rotate
                    0.5 3 sqrt 2 mul recip neg goto
                    0.5 3 sqrt 2 mul recip goto
                    stroke
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawtrimaze { /grid arg
    % grid fields:
    % width: count of cells across one side
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, wnw, s
        % for n, wsw, ese
    % field: as before
    % path: as before

    /width grid /width get def

    /getcenter { /hexcoord arg
        % convert hex coordinate to x,y
        hexcoord aload pop /n arg /ese arg
        [
            ese s3h mul
            ese neg half n add
        ]
    } def

    /getcellpath { /walls arg /tripos arg
        % one cell, centered on tripos, oriented appropriately
        tripos getcenter atranslate
        tripos aload pop add 3 mod 2 eq {
            180 rotate
        } if
        3 {
            0 1 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position 0 2 getinterval aload pop add 3 mymod cvi /tritype arg
        tritype 1 eq {
            0 setsinebowcolor doot
        } {
            tritype 0 eq { 30 rotate } { 90 rotate } ifelse
            0 1 2 { /i arg
                walls i get {
                    gsave
                        i 120 mul rotate
                        0.5 s3h neg goto
                        0.5 s3h goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/mazeengine {
    gsave
        grid /linewidth known {
            grid /linewidth get
        } {
            0.1
        } ifelse
        setlinewidth
        1 setlinecap
        1 setlinejoin

        grid /weave known {
            grid /inset known {
                grid /inset get
            } {
                0.1
            } ifelse
        } {
            0
        } ifelse /inset arg
        grid /field known {
            /fieldstep grid /field get length 1 sub recip def
        } if

        grid /cells get {
            gsave
                /cell arg
                cell 0 get /position arg
                cell 1 get /walls arg
                cell 2 get /field arg
                gsave
                    grid /field known {
                        field fieldstep mul 360 mul setsinebowcolor
                    } {
                        grid /pathcolor known {
                            grid /pathcolor get aload pop
                        } {
                            1 dup dup
                        } ifelse
                        setrgbcolor
                    } ifelse
                    position length 3 eq {
                        1.5 darken
                    } if
                    position walls getcellpath fill
                grestore
                position walls drawwalls
            grestore
        } forall

        grid /path known {
            grid /path get {
                getcenter aload pop mgoto
            } forall
            grid /field known {
                1 setgray
            } {
                1 0 0 setrgbcolor
            } ifelse
            stroke
            grid /path get 0 get getcenter aload pop dot
            grid /path get dup length 1 sub get getcenter aload pop dot
        } if
    grestore
} def

%%EndProlog
