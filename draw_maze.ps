%!
(dmmlib/base.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run

/atranslate { aload pop translate } def

/drawmaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position { 0.5 add } forall ]
    } def
    /getcellpath { /position arg
        position getcenter atranslate
        -0.5 -0.5 0.5 0.5 box
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 3 { /i arg
            walls i get {
                gsave
                    i 0 sub 90 mul rotate
                    0.5 -0.5 goto
                    0.5 0.5 goto
                    stroke
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawupsilonmaze { /grid arg
    /octagon_offset 0.5 22.5 tan mul def
    /diamond_offset 0.5 octagon_offset sub def
    /getcenter { /position arg
        [ position { 2 div 0.5 add } forall ]
    } def
    /getcellpath { /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            4 {
                0.5 octagon_offset neg goto
                0.5 octagon_offset goto
            } circrepeat closepath
        } {
            4 {
                diamond_offset 0 goto
            } circrepeat closepath
        } ifelse
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position 0 get 2 mod 0 eq {
            0 1 7 { /i arg
                walls i get {
                    gsave
                        i 45 mul rotate
                        0.5 octagon_offset neg goto
                        0.5 octagon_offset goto
                        stroke
                    grestore
                } if
            } for
        } {
            0 1 3 { /i arg
                walls i get {
                    gsave
                        i 90 mul rotate
                        diamond_offset 0 goto
                        0 diamond_offset goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/drawzetamaze { /grid arg
    % 0 0 grid /width get grid /height get box stroke
    /getcenter { /position arg
        [ position { 0.5 add } forall ]
    } def
    /getcellpath { /position arg
        position getcenter atranslate
        -0.5 -0.5 0.5 0.5 box
    } def
    /mgoto { goto } def
    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 2 6 { /i arg
            walls i get {
                gsave
                    i 0 sub 45 mul rotate
                    0.5 -0.5 goto
                    0.5 0.5 goto
                    stroke
                grestore
            } if
        } for
        % zeta paths
        1 2 7 { /i arg
            walls i get not {
                gsave
                    i 45 mul rotate
                    0.5 thicken
                    0.5 0 dot
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawcirclemaze { /grid arg
    % grid fields:
    % widths: array of ints, counting cells in each ring (from the middle out)
    % cells: list of lists containing coord (ring, cell) then list of boolean walls for ccw, in, cw, outs

    /widths grid /widths get def
    /radius widths length def

    /getcenter {
        2 dict begin
            /coord arg
            % given a (ring, cell) coordinate, return (r, theta) of center
            coord aload pop /cell arg /ring arg
            /r ring def
            /theta ring 0 eq { 0 } {
                widths ring get 360 exch div cell 0.5 add mul
            } ifelse def
            [ r theta polar]
        end
    } def

    /getbox {
        % given a ring/cell coordinate, return ccw, in, cw, out dimensions
        % not valid for ring 0
        2 dict begin
            /coord arg
            coord aload pop /cell arg /ring arg
            /in ring 0.5 sub def
            /out ring 0.5 add def
            /turn widths ring get 360 exch div def
            /ccw cell turn mul def
            /cw cell 1 add turn mul def
            [ccw in cw out]
        end
    } def
    /getcellpath { /position arg
        position 0 get 0 ne {
            /box position getbox def
            box 1 get box 0 get pgoto
            box 3 get box 0 get pgoto
            box 3 get box 2 get pgoto
            box 1 get box 2 get pgoto
            box 1 get box 0 get pgoto
            closepath
        } {
            0 0 0.5 circle closepath
        }ifelse
    } def

    /mgoto { ralop pgoto } def

    /drawwalls { /walls arg /position arg
        /outstart position 0 get 0 eq { 0 } { 3 } ifelse def
        outstart 0 ne {
            position getbox aload pop /out arg /cw arg /in arg /ccw arg
            walls 0 get { in ccw pgoto out ccw pgoto stroke } if
            walls 1 get { in ccw pgoto in cw pgoto stroke } if
            walls 2 get { in cw pgoto out cw pgoto stroke } if
            closepath stroke
        } {
            /ccw 0 def
            /cw 360 def
            /out 0.5 def
        } ifelse
        /outwall_n walls length outstart sub def
        outwall_n 0 ne {
            /outwall_len cw ccw sub outwall_n div def
            0 1 outwall_n 1 sub { /i arg
                walls outstart i add get {
                    out i       outwall_len mul ccw add pgoto
                    out i 1 add outwall_len mul ccw add pgoto stroke
                } if
            } for
        } if
    } def

    0 0 radius 0.5 sub circle stroke

    mazeengine

} def

/s3h 3 sqrt 2 div def

/h2c { /hexcoord arg
    % convert hex coordinate to x,y
    hexcoord aload pop /n arg /ese arg
    [
        ese s3h mul
        ese neg half n add
    ]
} def


/drawhexmaze { /grid arg
    % grid fields:
    % radius: count of cells in a radius, not including center
        % full distance across is 2 * radius + 1
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, n, wnw, wsw, s, ese
    % field: as before
    % path: as before

    /radius grid /radius get def

    /getcenter { h2c } def

    /getcellpath { /position arg
        % one cell, centered on position
        position getcenter atranslate
        6 {
            3 sqrt recip 0 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        0 1 5 { /i arg
            walls i get {
                gsave
                    i 0.5 add 60 mul rotate
                    0.5 3 sqrt 2 mul recip neg goto
                    0.5 3 sqrt 2 mul recip goto
                    stroke
                grestore
            } if
        } for
    } def

    mazeengine

} def

/drawtrimaze { /grid arg
    % grid fields:
    % width: count of cells across one side
    % cells: list of lists containing coord (ese, n) then list of boolean walls
        % for ene, wnw, s
        % for n, wsw, ese
    % field: as before
    % path: as before

    /width grid /width get def

    /getcenter { /hexcoord arg
        % convert hex coordinate to x,y
        hexcoord aload pop /n arg /ese arg
        [
            ese s3h mul
            ese neg half n add
        ]
    } def

    /getcellpath { /tripos arg
        % one cell, centered on tripos, oriented appropriately
        tripos getcenter atranslate
        tripos aload pop add 3 mod 2 eq {
            180 rotate
        } if
        3 {
            0 1 goto
        } circrepeat
        closepath
    } def

    /mgoto { goto } def

    /drawwalls { /walls arg /position arg
        position getcenter atranslate
        position aload pop add 3 mymod cvi /tritype arg
        tritype 1 eq {
            0 setsinebowcolor doot
        } {
            tritype 0 eq { 30 rotate } { 90 rotate } ifelse
            0 1 2 { /i arg
                walls i get {
                    gsave
                        i 120 mul rotate
                        0.5 s3h neg goto
                        0.5 s3h goto
                        stroke
                    grestore
                } if
            } for
        } ifelse
    } def

    mazeengine

} def

/mazeengine {
    gsave
        0.1 setlinewidth 1 setlinecap 1 setlinejoin

        grid /field known {
            /field grid /field get def
            /step field length 1 sub recip def
            0 1 field length 1 sub { /i arg
                gsave
                    i step mul 360 mul setsinebowcolor
                    field i get {
                        gsave
                            getcellpath fill
                        grestore
                    } forall
                grestore
            } for
        } if

        grid /cells get {
            gsave
                /cell arg
                cell 0 get /position arg
                cell 1 get /walls arg
                position walls drawwalls
            grestore
        } forall

        grid /path known {
            grid /path get {
                getcenter aload pop mgoto
            } forall
            grid /field known {
                1 setgray
            } {
                1 0 0 setrgbcolor
            } ifelse
            stroke
            grid /path get 0 get getcenter aload pop dot
            grid /path get dup length 1 sub get getcenter aload pop dot
        } if
    grestore
} def

%%EndProlog
